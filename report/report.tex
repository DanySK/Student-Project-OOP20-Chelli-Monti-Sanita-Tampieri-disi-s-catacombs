\documentclass[a4paper,12pt]{report}

\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{pgf-umlcd}
\usepackage[style=numeric-comp]{biblatex}

\addbibresource{bibliografia.bib}
\title{DISI's catacomb report}
\author{Chelli M., Monti G., Sanità R., Tampieri E.}

\begin{document}
    \maketitle
    \tableofcontents
    \chapter{Analisi}
    \section{Requisiti}
    \subsection{Requisiti funzionali}
    % Qui si meotte la parte di analisi
    \par Il team si pone l'obiettivo di realizzare un gioco 2D roguelike,
    ovvero caratterizzato dall'esplorazione di livelli generati proceduralmente
    di un dungeon, da un gameplay a turni, da grafica tile-based e la morte
    permanente del giocatore \cite{wiki:Roguelike}, simile ai giochi Enter the
    Gungeon e Nuclear Throne.
    \par Il giocatore dovrà affrontare una serie di piani composti da stanze contenenti
    nemici e oggetti fino ad arrivare a un boss finale. La mappa di gioco sarà generata
    in modo casuale e sarà casuale anche la stanza in cui il personaggio comincerà
    la sua avventura.
    \par Inizialmente il protagonista avrà 5 vite, un armatura al 100\%
    e un arma base che potrà cambiare con armi più avanzate che troverà nel corso
    della partità. Ad ogni colpo subito il personaggio perderà una percentuale dell'
    armatura nel momento in cui l'armatura raggiungerà la percentuale dello 0\%
    il danno subito toglierà una vita al personaggio, se il personaggio perde tutte
    e 5 le vite il giocatore ha perso e il gioco termina.
    \par Il gioco può terminare anche se viene sconfitto il boss della mappa ovvero
    un nemico di dimensione maggiore rispetto a quelli incontrati nelle stanze precedenti.
    Tale boss possiederà anche abilità superiori e armi letali per il personaggio.
    \par Una volta terminato il gioco è possibile scegliere se ricominciare la partita
    o recuperare un savepoint precedente.
    \par Se il giocatore si trova in difficoltà può trovare sparsi per la mappa di gioco
    alcune vite o armature che lo aiuteranno a sopravvivere fino alla battaglia finale.
    \par Esistono 2 tipi di nemici base:
    \begin{itemize}
        \item Nemici che attaccano da lontano
        \item Nemici che attaccano da vicino
    \end{itemize}
    \par Il gioco si basa sull'abilità del giocatore ma anche su una percentuale di
    fortuna nel trovare vite, armature ed armi che lo aiuteranno a sconfiggere il
    boss finale.
    \subsection{Requisiti non funzionali}
    \begin{itemize}
        \item Il gioco dovrà risultare fluido e reattivo anche su macchine con hardware non recenti..
        \item Il gioco dovrà avere una grafica e comandi chiari e intuitivi.
    \end{itemize}
    \section{Analisi e modello del dominio}
    % modello del dom
    \par Il sistema gestisce la generazione delle mappe con le varie stanze e le interazioni tra il
    personaggio e i nemici.
    \par Oltre ai nemici il personaggio potrà interagire con oggetti trovati nelle varie stanze.
    \par Il personaggio possiede principalmente un numero di vite che aumenteranno con gli oggetti
    o diminuiranno se colpiti da un nemico e una abilità speciale con un tempo di recupero variabile a seconda degli oggetti.
    \par I nemici potranno essere di due tipi principali, melee (che attaccano da vicino) e ranged (che attaccano da lontano)
    e si muoveranno all'interno delle stanze e avranno una vita massima. Nemici più difficili da sconfiggere,
    come i Boss avranno una maggiore vita massima e mosse speciali che useranno in determinati step durante il combattimento.
    \par La mappa è strutturata in più livelli. Ogni livello è costituito da varie stanze stanze dove compariranno nemnici,
    NPC ("Non Playable Character") e/o oggetti utilizzabili dal giocatore. Al termine di ogni stanza il giocatore si potrà
    spostare a quelle adiacenti o esplorare la mappa. Una sola stanza permetterà di passare al piano successivo.
    Arrivato all'ultimo paino in personaggio dovrà affrontare il Boss e dopo il combattimento il gioco terminerà.
    \par \par Gli elementi considerati nel modello sono sintetizzati in Figura 1.1


    \chapter{Design}
    \section{Architettura}
    \section{Design dettagliato} 
    \subsection{Sanita}
    \par Questa parte si concentrerà sugli aspetti relativi ai vari stati che costituiscono il gioco (menu, stato di gioco, stato di fine).
     Il sistema per la creazione di questi stati è la creazione di una classe astratta State dalla quale poi verranno
     estese tutte le classi che costituiscono i diversi stati. Questa classe rappresenta lo scheletro di un qualunque
     stato ed essendo una classe astratta l’implementazione di due metodi astratti quali update e render sarà diversa da
     stato a stato in modo che la logica e la grafica di ogni stato risulti diversa.
    %UML
    \par Questa parte verterà sulla gestione della schermata principale e su quella di fine gioco la quale poi introdurrà nuovamente
     alla schermata di menù. Il sistema per la gestione di questi due stati è la medesima, entrambi utilizzano il pattern Strategy
     infatti è possibile modificare la grafica di queste schermate senza andare ad impattare direttamente la logica che le gestisce.
     Questa scelta è stata fatta principalmente per evitare di infrangere SRP (Single Responsibility Principle) e quindi
     di incaricare una classe sia della gestione grafica di una schermata sia della sua logica creando così una complicazione
     in un futuro cambiamento.
    %UML
    \par Questa parte riguarda la gestione degli asset più precisamente la creazione di strutture e il caricamento delle
    immagini all’interno di esse. Il pattern utilizzato in questo caso è Singleton permettendo che ci sia un'unica istanza
    di AssetManager accessibile globalmente senza doversi preoccupare di fornire il riferimento a chi lo richiede.
    Questa scelta è stata fatta perché il caricamento delle immagini in quelle strutture basta farla una volta sola per poi
    permetterne l’accesso a chiunque lo richieda. Lo stesso ragionamento è stato fatto per il KeyManager essendo anche esso
    di utilità a più classi evitando anche in questo caso la creazione di istanze superflue
    %UML
    \par Questa parte di codice si occupa invece della cambiamento di stato ovvero delle transizioni che portano da uno stato
    a l’altro. In questo caso è stato utilizzata una Factory di transizione per via del fatto che la forma delle transizioni
    è la medesima  le uniche differenze riguardano gli stati di partenza e di arrivo e il messaggio che il giocatore vedrà.
    In questo non utilizzando una Factory avrei avuto tre classi in cui quasi tutto il codice veniva ripetuto e solo poche
    parti sarebbero cambiate  e così facendo avrei violato una regola base generale di buona programmazione ovvero
    DRY (Don’t Repeat Yourself).
    %UML

    \subsection{Monti}
    \par In questa sezione ci si concentrerà sugli aspetti riguardanti gli oggetti e le entità del gioco e della loro generazione.
    \par Dovendo creare oggetti con elementi in comune ho deciso di utilizzare un Template Method che ha come template la classe astratta GameObject
    Questa ha lo scopo di identificare un oggetto di gioco caratterizzato da poche elementali caratteristiche come la posizione nella mappa, la velocità e
    le dimensioni che esso ha.
    Inoltre viene specificato il metodo update nel quale gli oggetti di gioco aggiorneranno i loro stati, si muoveranno e/o spareranno o compieranno
    altre azioni.
    Il template viene poi esteso alle classi Entity, Weapon, SimplePotion e Projectile.
    \\
    \par
    \begin{tikzpicture}
        \tikzstyle{every node}=[font=\scriptsize]
            \begin {abstractclass}[text width=3.5cm]{GameObject}{0, -8}
                \attribute {\#posX: int}
                \attribute {\#posY: int}
                \operation {\#kind: GameObjectType}
                \attribute {\#speedX: int}
                \attribute {\#speedY: int}
                \attribute {\#hitBox: CollisionBox}
                \attribute {\#team: Team}
                \operation {+update(delta: long, others: List<GameObject>): List<GameObject>}
            \end {abstractclass}

            \begin {abstractclass}[text width=3.5cm]{Entity}{-5, 0}
                \inherit {GameObject}
                \attribute {\#face: Direction}
                \attribute {\#hp: int}
                \operation {\#kind: GameObjectType}
                \attribute {\#width: int}
                \attribute {\#height: int}
                \attribute {\#size: int}
                \attribute {\#tileMap: TileMap}
                \operation {+update(delta: long, others: List<GameObject>): List<GameObject>}
                \operation {\#move: void}
            \end {abstractclass}

            \begin {abstractclass}[text width=3.5cm]{Weapon}{5, 0}
                \inherit {GameObject}
                \attribute {\#strength: int}
                \attribute {\#ps: int}
                \operation {\#fireRate: long}
                \attribute {\#canFire: boolean}
                \attribute {\#fireDelay: long}
                \attribute {\#fireDelayCount: long}
                \operation {+update(delta: long, others: List<GameObject>): List<GameObject>}
                \operation {+fire(psx: int, psy: int): void}
            \end {abstractclass}

        \end{tikzpicture}
    \\
        \begin{center}
            In figura è rappresentato lo schema del Template Method del GameObject
        \end{center}
    \par Sempre con in mente il Template Method ho deciso di rendere astratte le classi Entity e Weapon, essendo entrambe una generalizzazione di quelli
    che sono rispettivamente i diversi personaggi (come il PLayer e i nemici) e le diverse armi presenti nel gioco.
    In particolare Entity è una classe astratta che rappresenta l'insieme degli oggetti definiti Living ("vivi"), cioè che si muovono, hanno una salute
    e compiono azioni tramite input o in modo autonomo (come muoversi, sparare o lasciare oggetti).
    Nel gioco sono attualmente implementate solo alcune entità basilari, ovvero il Player e tre nemici: Bat, Slime e Boss. Il metodo template però permette
    facilmente di aggiungere in futuro altre entità (p.e.: nuovi nemici, NPC, ecc.).
    Allo stesso tempo anche la classe astratta Weapon definisce l'insieme delle armi utilizzabili. Come Entity ci sono per ora solamente due tipi di Weapon
    chiamate Gun e Rifle ma è possibile aggiungerne altre facilmente.
    \\
    \par
        \begin{tikzpicture}
            \tikzstyle{every node}=[font=\scriptsize]

            \begin {abstractclass}[text width=3.5cm]{Entity}{-5, 0}
                \inherit {GameObject}
                \attribute {\#face: Direction}
                \attribute {\#hp: int}
                \operation {\#kind: GameObjectType}
                \attribute {\#width: int}
                \attribute {\#height: int}
                \attribute {\#size: int}
                \attribute {\#tileMap: TileMap}
                \operation {+update(delta: long, others: List<GameObject>): List<GameObject>}
                \operation {\#move: void}
            \end {abstractclass}

            \begin {class}[text width=3.5cm]{Bat}{0, -8}
                \inherit {Entity}
                \operation {+update(delta: long, others: List<GameObject>): List<GameObject>}
                \operation {+setShootingDirection(e: GameObject): void}
                \operation {-changeDirection: void}
            \end {class}

            \begin {class}[text width=3.5cm]{Boss}{0, 0}
                \inherit {Entity}
                \operation {+update(delta: long, others: List<GameObject>): List<GameObject>}
                \operation {+setShootingDirection(e: GameObject): void}
                \operation {-changeDirection: void}
            \end {class}

            \begin {class}[text width=3.5cm]{Slime}{0, +8}
                \inherit {Entity}
                \operation {+update(delta: long, others: List<GameObject>): List<GameObject>}
                \operation {+setCharacterToFollow(e: GameObject): void}
                \operation {-follow(): void}
            \end {class}

        \end{tikzpicture}
    \\
        \begin{center}
            In figura è rappresentato lo schema del Template Method della Entity
        \end{center}
    \par
        \begin{tikzpicture}
            \tikzstyle{every node}=[font=\scriptsize]

            \begin {abstractclass}[text width=3.5cm]{Weapon}{5, 0}
                \inherit {GameObject}
                \attribute {\#strength: int}
                \attribute {\#ps: int}
                \operation {\#fireRate: long}
                \attribute {\#canFire: boolean}
                \attribute {\#fireDelay: long}
                \attribute {\#fireDelayCount: long}
                \operation {+update(delta: long, others: List<GameObject>): List<GameObject>}
                \operation {+fire(psx: int, psy: int): void}
            \end {abstractclass}

            \begin {class}[text width=3.5cm]{Gun}{0, -8}
                \inherit {Weapon}
                \operation {+getStrength(): int}
                \operation {+getFireRate(): int}
                \operation {+getProjectileSpeed(): int}
            \end {class}

            \begin {class}[text width=3.5cm]{Rifle}{0, +8}
                \inherit {Weapon}
                \operation {+getStrength(): int}
                \operation {+getFireRate(): int}
                \operation {+getProjectileSpeed(): int}
            \end {class}
        \end{tikzpicture}
    \\
        \begin{center}
            In figura è rappresentato lo schema del Template Method della Weapon
        \end{center}
    \\
    \\
    \par Per la generazione degli oggetti di gioco ho deciso di distinguere la generazione delle entità da quella degli oggetti.
    La decisione di implementare due factory invece che una deriva da due fattori:
    \begin{itemize}
        \item Chiarezza dei nomi delle factory in relazione agli elementi creati
        \item Crezione di sole Entity per facilitare l'utilizzo
    \end{itemize}
    Cosi facendo la MobFactory gestisce la creazione di tutte le Entity sulla mappa, mentre la ObjectFactory gestisce i GameObject.
    Le factory forniscono metodi semplici per lo spawn, che avviene solamente solamente se la posizione selezionata (o generata randomicamente) è accessibile
    nella mappa.
    \\
    \par
        \begin{tikzpicture}
            \tikzstyle{every node}=[font=\scriptsize]

            \begin {interface}[text width=3.5cm]{ObjectFactory}{0, 0}

            \end {interface}

        \end{tikzpicture}
    \\
        \begin{center}
            In figura è rappresentato lo schema del Factory Method della MobFactory
        \end{center}
    \par AssetManagerProxy
    \par ImageRotatorFactory

    \chapter{Sviluppo}
    \section{Testing automatizzato}
    \section{Metodologia di lavoro}
    \subsection{Sanità}
    \par In questa parte esporrò il mio contributo per il progetto relativo alle interfacce grafiche al caricamento di risorse grafiche
    e testuali , alla gestione degli asset e delle animazioni del gioco , alla struttura del loop principale attraverso il quale si
    sviluppa il gioco e alla interazione con dispositivi esterni quali mouse e tastiera.
    \par La parte di cui mi sono maggiormente e occupato la GUI del gioco nello specifico la gestione degli stati attraverso i quali
    il gioco si sviluppa partendo dalla creazione di un generico stato State dal quale si estendono poi altri stati quali:
    MenuState , GameState e EndGameState.
    \par Un’altra parte di cui mi sono occupato riguarda le transizioni ovvero il cambiamento da uno stato a l’altro attraverso la creazione
    , per mezzo di  TransitionFactory , di un interfaccia che fa da ponte tra due stati. La gestione di degli stati e dei loro
    cambiamenti è affidata ad un'altra classe DungeonGame anche questa implementata da me. Questa classe si occupa di controllare
    in quale stato si trova il gioco e in quale stato dovrà trovarsi se il player muore o se finisce il gioco, in poche parole p la
    classe che gestisce la visualizzazione il funzionamento e il susseguirsi degli stati di gioco. Inoltre fornisce informazioni
    riguardanti la finestra principale del gioco creata dalla classe MainWindow di mia implementazione anche se la totalità delle
    informazioni riguardanti la finestra è disponibile a chi  ne facesse uso nella mia classe GameConfiguration.
    \par Il DungeonGame estende la classe Game che contiene i metodi necessari all’inizializzazione della finestra di gioco,
    il render degli aspetti di base ma soprattutto si occupa del loop principale del gioco.
    \par Un’altra classe di del mio codice è la gestione degli input di dispositivi esterni quale la tastiera KeyManager che
    gestisce i vari input da tastiera
    \par Una altra parte di mia responsabilità è il caricamento di risorse come si può vedere dal package catacombs/ui/utils
    e dall’AssetManager che fa uso di un’altra classe, GameSheet che si occupa di ritagliare le immagini in immagini più piccole
    in modo da separare i singoli frame di movimento dei personaggi.

    \subsection{Monti}
    \par Mi sono interessato per la quasi totalità ai GameObject e alle classi che lo estendono ad esclusione del Player, SimplePotions e Projectiles.
    In particolare mi sono occupato dell'analisi e della creazione di GameObject, di Entity, di Weapon e del package model.gen contenenti le Factory MobFactory
    e ObjectFactory.
    Sviluppo dei nemici Bat, Slime e Boss, della Weapon e classi derivate Gun e Rifle.
    Refactoring di alcune classi e metodi. Implementazione di piccole feature in classi altrui.
    Per ogni cambiamento o feature è stato creato un branch ed è stata richiesta la review per la pull request al master.
    Inoltre ho aggiunto qualche sprite al gioco.
    
    \section{Note di sviluppo}
    \subsection{Sanità}
    \begin{itemize}
            \item Uso di Optional per la gestione degli eventuali file non trovati
            \item Uso di basilari lambda expressions nei test automatizzati
    \end{itemize}
    \begin{itemize}
        \item Streams
        \item Lambda expressions
        \item Generici nelle factory
        \item Apache commons per l'utilizzo dei pair
    \end{itemize}
    \subsection{Monti}
    \chapter{Commenti finali}
    \section{Autovalutazione e lavori futuri}
    \subsection{Monti}
    Le difficoltà principali le ho riscontrate durante l'analisi del modello, essendo la prima esperienza di game design.
    Credo di aver fatto un lavoro nel complesso buono soprattutto nell'utlizzo dei pattern.
    Le uniche debolezze del gioco sono la poca varietà di armi e nemici e la grafica non troppo moderna, ma grazie al lavoro per ora svolto
    aggiungere nemici e armi risulterà molto semplice.
    \section{Difficoltà incontrate e commenti per i docenti}
    \appendix
    \chapter{Guida utente}
    \chapter{Esercitazioni di laboratorio}
    \printbibliography[heading=bibintoc]
\end{document}
