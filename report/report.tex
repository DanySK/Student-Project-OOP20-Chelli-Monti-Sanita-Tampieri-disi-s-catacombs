\documentclass[a4paper,12pt]{report}

\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{pgf-umlcd}
\usepackage[style=numeric-comp]{biblatex}

\addbibresource{bibliografia.bib}
\title{DISI's catacomb report}
\author{Chelli M., Monti G., Sanità R., Tampieri E.}

\begin{document}
    \maketitle
    \tableofcontents
    \chapter{Analisi}
    \section{Requisiti}
    \subsection{Requisiti funzionali}
    % Qui si meotte la parte di analisi
    \par Il team si pone l'obiettivo di realizzare un gioco 2D roguelike,
    ovvero caratterizzato dall'esplorazione di livelli generati proceduralmente
    di un dungeon, da un gameplay a turni, da grafica tile-based e la morte
    permanente del giocatore \cite{wiki:Roguelike}, simile ai giochi Enter the
    Gungeon e Nuclear Throne.
    \par Il giocatore dovrà affrontare una serie di piani composti da stanze contenenti
    nemici e oggetti fino ad arrivare a un boss finale. La mappa di gioco sarà generata
    in modo casuale e sarà casuale anche la stanza in cui il personaggio comincerà
    la sua avventura.
    \par Inizialmente il protagonista avrà 5 vite, un armatura al 100\%
    e un arma base che potrà cambiare con armi più avanzate che troverà nel corso
    della partità. Ad ogni colpo subito il personaggio perderà una percentuale dell'
    armatura nel momento in cui l'armatura raggiungerà la percentuale dello 0\%
    il danno subito toglierà una vita al personaggio, se il personaggio perde tutte
    e 5 le vite il giocatore ha perso e il gioco termina.
    \par Il gioco può terminare anche se viene sconfitto il boss della mappa ovvero
    un nemico di dimensione maggiore rispetto a quelli incontrati nelle stanze precedenti.
    Tale boss possiederà anche abilità superiori e armi letali per il personaggio.
    \par Una volta terminato il gioco è possibile scegliere se ricominciare la partita
    o recuperare un savepoint precedente.
    \par Se il giocatore si trova in difficoltà può trovare sparsi per la mappa di gioco
    alcune vite o armature che lo aiuteranno a sopravvivere fino alla battaglia finale.
    \par Esistono 2 tipi di nemici base:
    \begin{itemize}
        \item Nemici che attaccano da lontano
        \item Nemici che attaccano da vicino
    \end{itemize}
    \par Il gioco si basa sull'abilità del giocatore ma anche su una percentuale di
    fortuna nel trovare vite, armature ed armi che lo aiuteranno a sconfiggere il
    boss finale.
    \subsection{Requisiti non funzionali}
    \begin{itemize}
        \item Il gioco dovrà risultare fluido e reattivo anche su macchine con hardware non recenti..
        \item Il gioco dovrà avere una grafica e comandi chiari e intuitivi.
    \end{itemize}
    \section{Analisi e modello del dominio}
    % modello del dom
    \par Il sistema gestisce la generazione delle mappe con le varie stanze e le interazioni tra il
    personaggio e i nemici.
    \par Oltre ai nemici il personaggio potrà interagire con oggetti trovati nelle varie stanze.
    \par Il personaggio possiede principalmente un numero di vite che aumenteranno con gli oggetti
    o diminuiranno se colpiti da un nemico e una abilità speciale con un tempo di recupero variabile a seconda degli oggetti.
    \par I nemici potranno essere di due tipi principali, melee (che attaccano da vicino) e ranged (che attaccano da lontano)
    e si muoveranno all'interno delle stanze e avranno una vita massima. Nemici più difficili da sconfiggere,
    come i Boss avranno una maggiore vita massima e mosse speciali che useranno in determinati step durante il combattimento.
    \par La mappa è strutturata in più livelli. Ogni livello è costituito da varie stanze stanze dove compariranno nemnici,
    NPC ("Non Playable Character") e/o oggetti utilizzabili dal giocatore. Al termine di ogni stanza il giocatore si potrà
    spostare a quelle adiacenti o esplorare la mappa. Una sola stanza permetterà di passare al piano successivo.
    Arrivato all'ultimo paino in personaggio dovrà affrontare il Boss e dopo il combattimento il gioco terminerà.
    \par \par Gli elementi considerati nel modello sono sintetizzati in Figura 1.1


    \chapter{Design}
    \section{Architettura}
    \section{Design dettagliato}
    \subsection{Sanità}
    \par Questa parte si concentrerà sugli aspetti relativi ai vari stati che costituiscono il gioco (menu, stato di gioco, stato di fine).
     Il sistema per la creazione di questi stati è la creazione di una classe astratta State dalla quale poi verranno
     estese tutte le classi che costituiscono i diversi stati. Questa classe rappresenta lo scheletro di un qualunque
     stato ed essendo una classe astratta l’implementazione di due metodi astratti quali update e render sarà diversa da
     stato a stato in modo che la logica e la grafica di ogni stato risulti diversa.
    %UML
    \par Questa parte verterà sulla gestione della schermata principale e su quella di fine gioco la quale poi introdurrà nuovamente
     alla schermata di menù. Il sistema per la gestione di questi due stati è la medesima, entrambi utilizzano il pattern Strategy
     infatti è possibile modificare la grafica di queste schermate senza andare ad impattare direttamente la logica che le gestisce.
     Questa scelta è stata fatta principalmente per evitare di infrangere SRP (Single Responsibility Principle) e quindi
     di incaricare una classe sia della gestione grafica di una schermata sia della sua logica creando così una complicazione
     in un futuro cambiamento.
    %UML
    \par
    \begin{tikzpicture}
        \begin{abstractclass}[text width=2cm] \tiny{State}{0, 0}

            \operation\tiny{+ update(delta : long)}
            \operation\tiny{+ render(g2 : Graphics2D)}
        \end{abstractclass}

        \begin{class}[text width=2cm] \tiny{MenuState}{-5, -5}
            \inherit{State}

            \operation\tiny{+ update(delta : long)}
            \operation\tiny{+ render(g2 : Graphics2D)}
        \end{class}

        \begin{class}[text width=2cm] \tiny{GameState}{0, -5}
            \inherit{State}

            \operation\tiny{+ update(delta : long)}
            \operation\tiny{+ render(g2 : Graphics2D)}
        \end{class}

        \begin{class}[text width=2cm] \tiny{EndGameState}{5, -5}
            \inherit{State}

            \operation\tiny{+ update(delta : long)}
            \operation\tiny{+ render(g2 : Graphics2D)}
        \end{class}

    \end{tikzpicture}
    \par Questa parte riguarda la gestione degli asset più precisamente la creazione di strutture e il caricamento delle
    immagini all’interno di esse. Il pattern utilizzato in questo caso è Singleton permettendo che ci sia un'unica istanza
    di AssetManager accessibile globalmente senza doversi preoccupare di fornire il riferimento a chi lo richiede.
    Questa scelta è stata fatta perché il caricamento delle immagini in quelle strutture basta farla una volta sola per poi
    permetterne l’accesso a chiunque lo richieda. Lo stesso ragionamento è stato fatto per il KeyManager essendo anche esso
    di utilità a più classi evitando anche in questo caso la creazione di istanze superflue
    %UML
    \par Questa parte di codice si occupa invece della cambiamento di stato ovvero delle transizioni che portano da uno stato
    a l’altro. In questo caso è stato utilizzata una Factory di transizione per via del fatto che la forma delle transizioni
    è la medesima  le uniche differenze riguardano gli stati di partenza e di arrivo e il messaggio che il giocatore vedrà.
    In questo non utilizzando una Factory avrei avuto tre classi in cui quasi tutto il codice veniva ripetuto e solo poche
    parti sarebbero cambiate  e così facendo avrei violato una regola base generale di buona programmazione ovvero
    DRY (Don’t Repeat Yourself ).
    %UML

    \chapter{Sviluppo}
    \section{Testing automatizzato}
    \section{Metodologia di lavoro}
    \par In questa parte esporrò il mio contributo per il progetto relativo alle interfacce grafiche al caricamento di risorse grafiche
    e testuali , alla gestione degli asset e delle animazioni del gioco , alla struttura del loop principale attraverso il quale si
    sviluppa il gioco e alla interazione con dispositivi esterni quali mouse e tastiera.
    \par La parte di cui mi sono maggiormente e occupato la GUI del gioco nello specifico la gestione degli stati attraverso i quali
    il gioco si sviluppa partendo dalla creazione di un generico stato State dal quale si estendono poi altri stati quali:
    MenuState , GameState e EndGameState.
    \par Un’altra parte di cui mi sono occupato riguarda le transizioni ovvero il cambiamento da uno stato a l’altro attraverso la creazione
    , per mezzo di  TransitionFactory , di un interfaccia che fa da ponte tra due stati. La gestione di degli stati e dei loro
    cambiamenti è affidata ad un'altra classe DungeonGame anche questa implementata da me. Questa classe si occupa di controllare
    in quale stato si trova il gioco e in quale stato dovrà trovarsi se il player muore o se finisce il gioco, in poche parole p la
    classe che gestisce la visualizzazione il funzionamento e il susseguirsi degli stati di gioco. Inoltre fornisce informazioni
    riguardanti la finestra principale del gioco creata dalla classe MainWindow di mia implementazione anche se la totalità delle
    informazioni riguardanti la finestra è disponibile a chi  ne facesse uso nella mia classe GameConfiguration.
    \par Il DungeonGame estende la classe Game che contiene i metodi necessari all’inizializzazione della finestra di gioco,
    il render degli aspetti di base ma soprattutto si occupa del loop principale del gioco.
    \par Un’altra classe di del mio codice è la gestione degli input di dispositivi esterni quale la tastiera KeyManager che
    gestisce i vari input da tastiera
    \par Una altra parte di mia responsabilità è il caricamento di risorse come si può vedere dal package catacombs/ui/utils
    e dall’AssetManager che fa uso di un’altra classe, GameSheet che si occupa di ritagliare le immagini in immagini più piccole
    in modo da separare i singoli frame di movimento dei personaggi.
    \section{Note di sviluppo}
    \begin{itemize}
            \item Uso di Optional per la gestione degli eventuali file non trovati
            \item Uso di basilari lambda expressions nei test automatizzati
    \end{itemize}
    \chapter{Commenti finali}
    \section{Autovalutazione e lavori futuri}
    \section{Difficoltà incontrate e commenti per i docenti}
    \appendix
    \chapter{Guida utente}
    \chapter{Esercitazioni di laboratorio}
    \printbibliography[heading=bibintoc]
\end{document}
